= SalesPoint Framework - Technical Reference
Andreas Zaschka; Paul Henke; Oliver Gierke;
:source-base: ../../main/java/org/salespointframework
:source-base-test: ../../test/java/org/salespointframework
:toc:
{version}

:toc:

[[preface]]
== Preface
=== Typographic Conventions
Two typographic conventions are employed throughout this document to highlight specific phrases. The following paragraphs describe when and why these highlightings are used:
+Keywords+
The Keyword font is used to denote variable names, class names, type names, java keywords, java package names and so forth.
_Termini_
Proper names and termini are printed in termini font.

=== Introduction
The Salespoint Framework is intended to minimize developing effort of point-of-sale applications. Salespoint 2010 users complainted about complexity, missing features and bugs. Thus, the decision was made to re-design and re-implement the framework from scratch. In 2013 some parts again were re-implemented with components of the spring project. Our development goal was an easy-to-use framework primarily targeted for educational purposes. As such Salespoint 5 is not tailored to any specific application, but designed with a wide area of applications in mind.
Models and design patterns employed in Salespoint 5 are inspired by “Enterprise Patterns and MDA: Building Better Software with Archetype Patterns and UML” by Jim Arlow [1]. An overview of the functionality of the new features in Salespoint 5 are detailed in this document.
We would like to thank all Salespoint users who submitted their feedback and encourage future users of Salespoint 5 to do the same.

[[architecture]]
== Technical Architecture
=== Spring
In contrast to earlier versions of the Salespoint Framework, Salespoint 5 obeys the MVC pattern. Salespoint 5 can be seen as the Model of an MVC application, no parts of the View or the Controller are implemented in the framework. 
Salespoint 5 is designed as basis for development of web applications, using the _Spring Framework_ [6] to implement Views and Controllers. To further ease the development, Salespoint 5 includes property editors to convert string based representations to Salespoint 5 identifier types. Furthermore, JSP tags to check, if a user is logged in and if a user has a certain capability are included in the framework.
As a big new approach in development with JPA, the Spring Framework with its repository interfaces can make the work very fast, clean and easy. The Crudrepository provides the basic methods for working with the database (CRUD stands for Create, Read, Update and Delete).

===	JodaMoney
In Salespoint 5.3.X money class and its related components were replaced by the Joda-Money [7] project. 
Prices and other money values are represented as +org.joda.money.Money+ or for more precisison as +org.joda.money.BigMoney+ objects.
Due to the fact, that all representing objects are immutable, all arithmetic functions produce a new object (see Listing 1).

.Example for JodaMoney operations
[source, java]
----
Money value_1 = Money.parse(“USD 23.07”);
Money value_2 = Money.parse(“USD 18.07”);
Money sum = value_1.plus(value_2);
----
Joda-Money also supports Currency (see _Example for JodaMoney operations_). 
A set of loaded currencies is provided by an instance of CurrencyUnitDataProvider. But new and funky CurrencyUnits can be created to. So with this currencies, money values can be converted from one to another currency.

===	Configuration of Salespoint 5
The configuration for an application can be modified on the application class in the root package (e.g.  videoshop.Videoshop for the videoshop project). 
Methods, annotated with +@Configuration+, will be scanned at the beginning of the deployment on the application server (in this case Spring Boot). This configuration files will tell the application server the settings for the application.
By overriding the configuration method, you can specify the login behaviour or security functions. 
For a basic login strategy the videoshop is a good start. 
There you can see, that with authorizeRequests() an authorization will be set. 
Following by matchers, you can specify the pages, this authorization is made on.
Further, you can easily set an login page with formLogin() and the path to the login page with loginProcessingUrl("/login"). 
Analogue the logout settings works like login system.

===	DataInitilizer or filling Application with Test-Data
Every Application should be tested, so an easy way is, to use test data. 
So for this goal a recommend solution is, to load on every start of the application a bundle of test data into your system.
As shown in the Videoshop project, a Datainitilizer class is registered and creates a lot of data and finally adds this data to the application. 
For that purpose the Salespoint has an Interface +org.salespointframework.core.DataInitializer+, which can be used.


[[stack]]
== Technical Stack

[[stack.spring-boot]]
### Spring Boot

Rapid application development framework based on Spring (see below).

- http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle[Reference documentation]
- https://spring.io/guides[Getting started guides]
- http://projects.spring.io/spring-boot[Project home]

[[stack.spring]]
### Spring 4

The de-facto standard Java application framework.

- https://spring.io/guides[Getting started guides]
- http://projects.spring.io/spring-framework[Project home]

[[stack.spring-data-jpa]]
### Spring Data JPA

Spring module to easily build data acess layers using JPA 2.1 (Java Persistence API).

- https://spring.io/guides?filter=jpa[Getting started guides]
- http://projects.spring.io/spring-data-jpa[Project home]

[[stack.thymeleaf]]
### Thymeleaf

Library to build HTML web views using natural templating.

- https://spring.io/guides/gs/serving-web-content[Getting stared guide]
- http://www.thymeleaf.org/doc/usingthymeleaf.html[Tutorial]

[[modules]]
== Business modules

[[modules.useraccount]]
=== Useraccount
To manage system accounts, Salespoint 5 has a notation of a user in the form of the User interface. 
Users are managed by the UserAccountManager, who is also an interface. 
Every user is uniquely identified by a +org.salespointframework.core.useraccount.UserAccountIdentifier+, which also serves as primary key attribute for the database. 

.UserRole
+org.salespointframework.core.useraccount.Role+ s in conjunction with authorization tag _hasRole()_ can be used to change the appearance of a View, depending on a user’s status. 
For example, a View for a user having an “administrator” role may display different content, for example delete buttons, than for a user not having that role. 
Thus, roles allow for flexibility and assist in code reuse, when designing the View.

.Login
To reduce code repetition, Salespoint 5 contains code to automate user log in. 
Using a JSP template, a special login form is generated, which is handled by an interceptor. 
The interceptor verifies the user password and associates the current session with the user using _<login>_ and _<logoff>_. 
The session is required, because multiple users can be logged on at the same time.

.Limitation
Due to the fact, that Salespoint use the SecuirtyContext for authentication, the +UserAccount+ cannot be extended.
In the background the +org.salespointframework.core.useraccount.UserAccount+ is converted to an instance of 
+org.springframework.security.core.userdetails.UserDetails+ .
[NOTE]
.Extend the UserAccount
====
If this properties don’t meet all requirements, wrap the +UserAccount+ in a new +Entity+. + 
Put all the new features in this new +Entity+ and connect this information via a +OneToOne+ relationship with the +UserAccount+. +
An Example is the videoshop project.

.Example for UserAccount extension
[source, java]
----
@Entity
public class UserAccountExtension {

	private String string;
	private Integer integer;

	@OneToOne
	private UserAccount userAccount;
}
----
====

[[modules.product]]
=== Product
Salespoint 5 is intended as framework for point-of-sale applications. 
The items for sale are called “products” and represented by instances of classes who implement the Product interface. 
To represent different kinds of products, +PersistentProduct+ can be sub-classed.
PersistentProducts are aggregated by PersistentCatalog (see Section <<modules.catalog>>).

.Product Identifier
Products are supposed to be an abstraction, like an item on display or a picture in a catalog. 
ProductInstances are used to represent the actual item you get, when you a buy a product. 
Products are identified using a ProductIndentifier, whereas ProductInstances are identified by a SerialNumber. 
ProductInstances can be thought of as identifiable instances of a certain product, which are identical apart from their SerialNumber.

[[modules.catalog]]
=== Catalog
The Catalog interface was designed to manage Products and ProductFeatures in the system.
It provides functionality to add, remove, and find Products.
Products can be searched by their name or category.
Products and ProductFeatures are more closely described in Section <<modules.product>>.
The +PersistentCatalog+ is an implementation of the +Catalog+ interface.
Additionally PersistentCatalog provides an update()-method to update and merge existing PersistentProducts to the database. 
The find() methods request the database in the form of CriteriaQuerys which will be processed by JPA and results are returned in the form of Iterables. 
The reason for this is to make returned objects immutable without making it difficult to iterate over these results.

[appendix]
== Asciidoc template

Some random snippets to show how Asciidoc is used. For more examples see the http://asciidoctor.org/docs/user-manual[user manual].

.Example for code snippets
[source, java]
----
class SomeClass { }
----

.Example for code included from the sources
[source, java]
----
include::{source-base-test}/AbstractIntegrationTests.java[tags=testBase]
----